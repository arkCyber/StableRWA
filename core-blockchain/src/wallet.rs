// =====================================================================================
// File: core-blockchain/src/wallet.rs
// Description: Production-grade wallet management for blockchain operations
// Author: arkSong (arksong2018@gmail.com)
// =====================================================================================

use crate::{BlockchainError, BlockchainNetwork, Address, Transaction};
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing::{debug, error, info, warn};
use uuid::Uuid;

/// Wallet management trait
#[async_trait]
pub trait WalletManager: Send + Sync {
    /// Create a new wallet
    async fn create_wallet(&self, user_id: &str, network: BlockchainNetwork) -> Result<Wallet, BlockchainError>;
    
    /// Import wallet from private key
    async fn import_wallet(&self, user_id: &str, private_key: &str, network: BlockchainNetwork) -> Result<Wallet, BlockchainError>;
    
    /// Get wallet by ID
    async fn get_wallet(&self, wallet_id: &str) -> Result<Option<Wallet>, BlockchainError>;
    
    /// Get wallets for user
    async fn get_user_wallets(&self, user_id: &str) -> Result<Vec<Wallet>, BlockchainError>;
    
    /// Sign transaction
    async fn sign_transaction(&self, wallet_id: &str, transaction: &Transaction) -> Result<SignedTransaction, BlockchainError>;
    
    /// Get wallet balance
    async fn get_balance(&self, wallet_id: &str) -> Result<WalletBalance, BlockchainError>;
    
    /// Update wallet balance
    async fn update_balance(&self, wallet_id: &str, balance: WalletBalance) -> Result<(), BlockchainError>;
    
    /// Lock wallet for security
    async fn lock_wallet(&self, wallet_id: &str) -> Result<(), BlockchainError>;
    
    /// Unlock wallet with password
    async fn unlock_wallet(&self, wallet_id: &str, password: &str) -> Result<(), BlockchainError>;
}

/// Wallet information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Wallet {
    pub id: String,
    pub user_id: String,
    pub address: Address,
    pub network: BlockchainNetwork,
    pub wallet_type: WalletType,
    pub is_primary: bool,
    pub is_locked: bool,
    pub encrypted_private_key: Option<String>,
    pub public_key: String,
    pub derivation_path: Option<String>,
    pub metadata: HashMap<String, serde_json::Value>,
    pub created_at: chrono::DateTime<chrono::Utc>,
    pub updated_at: chrono::DateTime<chrono::Utc>,
}

impl Wallet {
    pub fn new(
        user_id: String,
        address: Address,
        network: BlockchainNetwork,
        public_key: String,
    ) -> Self {
        let now = chrono::Utc::now();
        Self {
            id: Uuid::new_v4().to_string(),
            user_id,
            address,
            network,
            wallet_type: WalletType::Generated,
            is_primary: false,
            is_locked: false,
            encrypted_private_key: None,
            public_key,
            derivation_path: None,
            metadata: HashMap::new(),
            created_at: now,
            updated_at: now,
        }
    }

    pub fn with_encrypted_key(mut self, encrypted_key: String) -> Self {
        self.encrypted_private_key = Some(encrypted_key);
        self
    }

    pub fn with_derivation_path(mut self, path: String) -> Self {
        self.derivation_path = Some(path);
        self
    }

    pub fn set_primary(mut self, is_primary: bool) -> Self {
        self.is_primary = is_primary;
        self
    }

    pub fn is_available(&self) -> bool {
        !self.is_locked
    }
}

/// Wallet types
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum WalletType {
    Generated,    // Generated by the system
    Imported,     // Imported from external source
    Hardware,     // Hardware wallet
    MultiSig,     // Multi-signature wallet
    Custodial,    // Custodial wallet
}

/// Wallet balance information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WalletBalance {
    pub native_balance: String,  // Native token balance (ETH, SOL, DOT)
    pub token_balances: HashMap<String, TokenBalance>,
    pub total_value_usd: Option<f64>,
    pub last_updated: chrono::DateTime<chrono::Utc>,
}

impl WalletBalance {
    pub fn new(native_balance: String) -> Self {
        Self {
            native_balance,
            token_balances: HashMap::new(),
            total_value_usd: None,
            last_updated: chrono::Utc::now(),
        }
    }

    pub fn add_token_balance(&mut self, token_address: String, balance: TokenBalance) {
        self.token_balances.insert(token_address, balance);
        self.last_updated = chrono::Utc::now();
    }
}

/// Token balance information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TokenBalance {
    pub balance: String,
    pub decimals: u8,
    pub symbol: String,
    pub name: String,
    pub contract_address: String,
    pub value_usd: Option<f64>,
}

/// Signed transaction
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SignedTransaction {
    pub transaction: Transaction,
    pub signature: String,
    pub signed_at: chrono::DateTime<chrono::Utc>,
    pub signer_address: String,
}

/// In-memory wallet manager implementation
pub struct InMemoryWalletManager {
    wallets: Arc<RwLock<HashMap<String, Wallet>>>,
    user_wallets: Arc<RwLock<HashMap<String, Vec<String>>>>,
    balances: Arc<RwLock<HashMap<String, WalletBalance>>>,
}

impl InMemoryWalletManager {
    pub fn new() -> Self {
        Self {
            wallets: Arc::new(RwLock::new(HashMap::new())),
            user_wallets: Arc::new(RwLock::new(HashMap::new())),
            balances: Arc::new(RwLock::new(HashMap::new())),
        }
    }
}

#[async_trait]
impl WalletManager for InMemoryWalletManager {
    async fn create_wallet(&self, user_id: &str, network: BlockchainNetwork) -> Result<Wallet, BlockchainError> {
        // Generate new key pair (simplified - in production use proper crypto)
        let private_key = self.generate_private_key(&network)?;
        let public_key = self.derive_public_key(&private_key, &network)?;
        let address = self.derive_address(&public_key, &network)?;

        let wallet = Wallet::new(
            user_id.to_string(),
            address,
            network,
            public_key,
        );

        // Store wallet
        let mut wallets = self.wallets.write().await;
        let mut user_wallets = self.user_wallets.write().await;

        wallets.insert(wallet.id.clone(), wallet.clone());
        user_wallets
            .entry(user_id.to_string())
            .or_insert_with(Vec::new)
            .push(wallet.id.clone());

        // Initialize balance
        let balance = WalletBalance::new("0".to_string());
        self.balances.write().await.insert(wallet.id.clone(), balance);

        info!(
            wallet_id = %wallet.id,
            user_id = %user_id,
            network = ?network,
            address = %wallet.address.address,
            "Wallet created successfully"
        );

        Ok(wallet)
    }

    async fn import_wallet(&self, user_id: &str, private_key: &str, network: BlockchainNetwork) -> Result<Wallet, BlockchainError> {
        // Derive public key and address from private key
        let public_key = self.derive_public_key(private_key, &network)?;
        let address = self.derive_address(&public_key, &network)?;

        let mut wallet = Wallet::new(
            user_id.to_string(),
            address,
            network,
            public_key,
        );
        wallet.wallet_type = WalletType::Imported;

        // Encrypt and store private key
        let encrypted_key = self.encrypt_private_key(private_key)?;
        wallet = wallet.with_encrypted_key(encrypted_key);

        // Store wallet
        let mut wallets = self.wallets.write().await;
        let mut user_wallets = self.user_wallets.write().await;

        wallets.insert(wallet.id.clone(), wallet.clone());
        user_wallets
            .entry(user_id.to_string())
            .or_insert_with(Vec::new)
            .push(wallet.id.clone());

        info!(
            wallet_id = %wallet.id,
            user_id = %user_id,
            network = ?network,
            "Wallet imported successfully"
        );

        Ok(wallet)
    }

    async fn get_wallet(&self, wallet_id: &str) -> Result<Option<Wallet>, BlockchainError> {
        let wallets = self.wallets.read().await;
        Ok(wallets.get(wallet_id).cloned())
    }

    async fn get_user_wallets(&self, user_id: &str) -> Result<Vec<Wallet>, BlockchainError> {
        let user_wallets = self.user_wallets.read().await;
        let wallets = self.wallets.read().await;

        if let Some(wallet_ids) = user_wallets.get(user_id) {
            let mut result = Vec::new();
            for wallet_id in wallet_ids {
                if let Some(wallet) = wallets.get(wallet_id) {
                    result.push(wallet.clone());
                }
            }
            Ok(result)
        } else {
            Ok(Vec::new())
        }
    }

    async fn sign_transaction(&self, wallet_id: &str, transaction: &Transaction) -> Result<SignedTransaction, BlockchainError> {
        let wallets = self.wallets.read().await;
        let wallet = wallets.get(wallet_id)
            .ok_or_else(|| BlockchainError::WalletNotFound(wallet_id.to_string()))?;

        if wallet.is_locked {
            return Err(BlockchainError::WalletLocked(wallet_id.to_string()));
        }

        // In production, this would use the actual private key to sign
        let signature = self.sign_transaction_data(transaction, wallet)?;

        Ok(SignedTransaction {
            transaction: transaction.clone(),
            signature,
            signed_at: chrono::Utc::now(),
            signer_address: wallet.address.address.clone(),
        })
    }

    async fn get_balance(&self, wallet_id: &str) -> Result<WalletBalance, BlockchainError> {
        let balances = self.balances.read().await;
        balances.get(wallet_id)
            .cloned()
            .ok_or_else(|| BlockchainError::WalletNotFound(wallet_id.to_string()))
    }

    async fn update_balance(&self, wallet_id: &str, balance: WalletBalance) -> Result<(), BlockchainError> {
        let mut balances = self.balances.write().await;
        balances.insert(wallet_id.to_string(), balance);
        
        debug!(
            wallet_id = %wallet_id,
            native_balance = %balances.get(wallet_id).unwrap().native_balance,
            "Wallet balance updated"
        );
        
        Ok(())
    }

    async fn lock_wallet(&self, wallet_id: &str) -> Result<(), BlockchainError> {
        let mut wallets = self.wallets.write().await;
        if let Some(wallet) = wallets.get_mut(wallet_id) {
            wallet.is_locked = true;
            wallet.updated_at = chrono::Utc::now();
            info!(wallet_id = %wallet_id, "Wallet locked");
            Ok(())
        } else {
            Err(BlockchainError::WalletNotFound(wallet_id.to_string()))
        }
    }

    async fn unlock_wallet(&self, wallet_id: &str, _password: &str) -> Result<(), BlockchainError> {
        // In production, verify password before unlocking
        let mut wallets = self.wallets.write().await;
        if let Some(wallet) = wallets.get_mut(wallet_id) {
            wallet.is_locked = false;
            wallet.updated_at = chrono::Utc::now();
            info!(wallet_id = %wallet_id, "Wallet unlocked");
            Ok(())
        } else {
            Err(BlockchainError::WalletNotFound(wallet_id.to_string()))
        }
    }
}

impl InMemoryWalletManager {
    /// Generate a new private key (simplified implementation)
    fn generate_private_key(&self, _network: &BlockchainNetwork) -> Result<String, BlockchainError> {
        // In production, use proper cryptographic key generation
        Ok(format!("private_key_{}", Uuid::new_v4()))
    }

    /// Derive public key from private key
    fn derive_public_key(&self, private_key: &str, _network: &BlockchainNetwork) -> Result<String, BlockchainError> {
        // In production, use proper cryptographic derivation
        Ok(format!("public_key_from_{}", private_key))
    }

    /// Derive address from public key
    fn derive_address(&self, public_key: &str, network: &BlockchainNetwork) -> Result<Address, BlockchainError> {
        // In production, use proper address derivation for each network
        let address = match network {
            BlockchainNetwork::EthereumMainnet | BlockchainNetwork::EthereumTestnet => {
                format!("0x{}", &public_key[..40])
            }
            BlockchainNetwork::SolanaMainnet | BlockchainNetwork::SolanaTestnet => {
                format!("Sol{}", &public_key[..40])
            }
            BlockchainNetwork::PolkadotMainnet | BlockchainNetwork::PolkadotTestnet => {
                format!("Dot{}", &public_key[..40])
            }
        };

        Ok(Address::new(address, network.clone()))
    }

    /// Encrypt private key for storage
    fn encrypt_private_key(&self, private_key: &str) -> Result<String, BlockchainError> {
        // In production, use proper encryption
        Ok(format!("encrypted_{}", private_key))
    }

    /// Sign transaction data
    fn sign_transaction_data(&self, transaction: &Transaction, _wallet: &Wallet) -> Result<String, BlockchainError> {
        // In production, use proper cryptographic signing
        Ok(format!("signature_for_{}", transaction.id))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_create_wallet() {
        let manager = InMemoryWalletManager::new();
        let user_id = "test_user";
        let network = BlockchainNetwork::EthereumTestnet;

        let wallet = manager.create_wallet(user_id, network).await.unwrap();

        assert_eq!(wallet.user_id, user_id);
        assert_eq!(wallet.network, BlockchainNetwork::EthereumTestnet);
        assert_eq!(wallet.wallet_type, WalletType::Generated);
        assert!(!wallet.is_locked);
    }

    #[tokio::test]
    async fn test_import_wallet() {
        let manager = InMemoryWalletManager::new();
        let user_id = "test_user";
        let private_key = "test_private_key";
        let network = BlockchainNetwork::EthereumTestnet;

        let wallet = manager.import_wallet(user_id, private_key, network).await.unwrap();

        assert_eq!(wallet.user_id, user_id);
        assert_eq!(wallet.wallet_type, WalletType::Imported);
        assert!(wallet.encrypted_private_key.is_some());
    }

    #[tokio::test]
    async fn test_get_user_wallets() {
        let manager = InMemoryWalletManager::new();
        let user_id = "test_user";

        // Create multiple wallets
        manager.create_wallet(user_id, BlockchainNetwork::EthereumTestnet).await.unwrap();
        manager.create_wallet(user_id, BlockchainNetwork::SolanaTestnet).await.unwrap();

        let wallets = manager.get_user_wallets(user_id).await.unwrap();
        assert_eq!(wallets.len(), 2);
    }

    #[tokio::test]
    async fn test_wallet_locking() {
        let manager = InMemoryWalletManager::new();
        let user_id = "test_user";
        let network = BlockchainNetwork::EthereumTestnet;

        let wallet = manager.create_wallet(user_id, network).await.unwrap();
        assert!(!wallet.is_locked);

        // Lock wallet
        manager.lock_wallet(&wallet.id).await.unwrap();
        let locked_wallet = manager.get_wallet(&wallet.id).await.unwrap().unwrap();
        assert!(locked_wallet.is_locked);

        // Unlock wallet
        manager.unlock_wallet(&wallet.id, "password").await.unwrap();
        let unlocked_wallet = manager.get_wallet(&wallet.id).await.unwrap().unwrap();
        assert!(!unlocked_wallet.is_locked);
    }

    #[tokio::test]
    async fn test_balance_management() {
        let manager = InMemoryWalletManager::new();
        let user_id = "test_user";
        let network = BlockchainNetwork::EthereumTestnet;

        let wallet = manager.create_wallet(user_id, network).await.unwrap();

        // Initial balance should be 0
        let balance = manager.get_balance(&wallet.id).await.unwrap();
        assert_eq!(balance.native_balance, "0");

        // Update balance
        let mut new_balance = WalletBalance::new("1000000000000000000".to_string()); // 1 ETH in wei
        new_balance.add_token_balance(
            "0x123...".to_string(),
            TokenBalance {
                balance: "1000".to_string(),
                decimals: 18,
                symbol: "TEST".to_string(),
                name: "Test Token".to_string(),
                contract_address: "0x123...".to_string(),
                value_usd: Some(100.0),
            }
        );

        manager.update_balance(&wallet.id, new_balance).await.unwrap();

        let updated_balance = manager.get_balance(&wallet.id).await.unwrap();
        assert_eq!(updated_balance.native_balance, "1000000000000000000");
        assert_eq!(updated_balance.token_balances.len(), 1);
    }
}
